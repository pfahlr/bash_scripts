#!/usr/bin/env python3
import argparse
import json
import os
import shlex
import sys
from textwrap import shorten
from typing import Any, Dict, List, Optional

DEFAULT_CONFIG_PATH = os.path.expanduser("~/.myshellenv.manager")
STATE_ENV_VAR = "MYSHENV_STATE"


class ConfigError(Exception):
  pass


def load_config(path: str) -> Dict[str, Any]:
  try:
    with open(path, "r", encoding="utf-8") as f:
      data = json.load(f)
  except FileNotFoundError:
    raise ConfigError(f"Config file not found: {path}")
  except json.JSONDecodeError as e:
    raise ConfigError(f"Config file is not valid JSON: {path}\n{e}")

  if not isinstance(data, dict) or "items" not in data or not isinstance(data["items"], dict):
    raise ConfigError("Config must have an 'items' object mapping names to items.")

  return data["items"]


def item_to_env_map(item_def: Any) -> Dict[str, str]:
  vals = item_def.get("values")
  env: Dict[str, str] = {}

  # Allow: "values": { "VAR": "VALUE", ... }
  if isinstance(vals, dict):
    for k, v in vals.items():
      env[str(k)] = "" if v is None else str(v)

  # Or: "values": [ { "VAR": "VALUE" }, { "VAR2": "VALUE2" } ]
  elif isinstance(vals, list):
    for entry in vals:
      if isinstance(entry, dict):
        for k, v in entry.items():
          env[str(k)] = "" if v is None else str(v)

  return env


def parse_names(tokens: Optional[List[str]]) -> List[str]:
  result: List[str] = []
  for tok in tokens or []:
    for part in tok.split(","):
      name = part.strip()
      if name:
        result.append(name)
  return result


def get_state() -> Dict[str, Any]:
  raw = os.environ.get(STATE_ENV_VAR)
  if not raw:
    return {}
  try:
    data = json.loads(raw)
    if isinstance(data, dict):
      return data
  except Exception:
    return {}
  return {}


def emit_state(state: Dict[str, Any]) -> str:
  encoded = shlex.quote(json.dumps(state))
  return f"export {STATE_ENV_VAR}={encoded}"


def generate_exports(items: Dict[str, Any], names: List[str]) -> Dict[str, str]:
  """
  Merge env vars for the given items.
  Later items override earlier ones on conflicts (same variable name).
  """
  merged: Dict[str, str] = {}
  for name in names:
    item_def = items.get(name)
    if item_def is None:
      print(f"# WARNING: item '{name}' not found in config", file=sys.stderr)
      continue
    env_map = item_to_env_map(item_def)
    merged.update(env_map)
  return merged


def env_active(env_map: Dict[str, str]) -> bool:
  """True if all variables are present and match configured values."""
  if not env_map:
    return False
  for k, v in env_map.items():
    if os.environ.get(k) != v:
      return False
  return True


def diff_env(vars_expected: Dict[str, str]) -> List[str]:
  lines: List[str] = []
  for k, v in vars_expected.items():
    cur = os.environ.get(k)
    if cur == v:
      lines.append(f"✔ {k}={v}")
    elif cur is None:
      lines.append(f"✖ {k} (missing, expected {v})")
    else:
      lines.append(f"✖ {k}={cur} (expected {v})")
  return lines


def describe_collisions(
  items: Dict[str, Any],
  names: List[str],
  state: Dict[str, Any],
) -> List[str]:
  """
  Produce human-readable notes about:
    - collisions between the requested items themselves
    - collisions between requested items and currently-active items
  """
  notes: List[str] = []

  # Build env maps for requested items
  item_envs: Dict[str, Dict[str, str]] = {}
  for name in names:
    item_def = items.get(name)
    if item_def is None:
      continue
    item_envs[name] = item_to_env_map(item_def)

  req_names = list(item_envs.keys())

  # 1) Collisions among requested items
  for i in range(len(req_names)):
    ni = req_names[i]
    env_i = item_envs[ni]
    keys_i = set(env_i.keys())
    for j in range(i + 1, len(req_names)):
      nj = req_names[j]
      env_j = item_envs[nj]
      keys_j = set(env_j.keys())
      overlap = keys_i & keys_j
      if not overlap:
        continue

      # Conflicting values
      for var in sorted(overlap):
        vi = env_i[var]
        vj = env_j[var]
        if vi != vj:
          notes.append(
            f"# NOTE: variable {var} has conflicting values between items "
            f"'{ni}' ('{vi}') and '{nj}' ('{vj}'); later item in the argument "
            f"list will win when activating both."
          )

      # Different variable sets for colliding items
      if keys_i != keys_j:
        only_i = sorted(keys_i - keys_j)
        only_j = sorted(keys_j - keys_i)
        notes.append(
          f"# WARNING: items '{ni}' and '{nj}' share variables "
          f"{', '.join(sorted(overlap))} but have different variable sets."
        )
        if only_i:
          notes.append(f"#          Variables only in '{ni}': {', '.join(only_i)}")
        if only_j:
          notes.append(f"#          Variables only in '{nj}': {', '.join(only_j)}")

  # 2) Collisions vs currently-active items in state
  for new_name, new_env in item_envs.items():
    new_keys = set(new_env.keys())
    for active_name, entry in state.items():
      if active_name == new_name:
        continue
      if not isinstance(entry, dict) or not entry.get("active"):
        continue

      active_env = entry.get("vars")
      if not isinstance(active_env, dict):
        item_def = items.get(active_name)
        if item_def is None:
          continue
        active_env = item_to_env_map(item_def)

      active_keys = set(active_env.keys())
      overlap = new_keys & active_keys
      if not overlap:
        continue

      notes.append(
        f"# NOTE: activating '{new_name}' would override/deactivate active item "
        f"'{active_name}' for variables: {', '.join(sorted(overlap))}."
      )

      if new_keys != active_keys:
        only_new = sorted(new_keys - active_keys)
        only_old = sorted(active_keys - new_keys)
        notes.append(
          f"# WARNING: items '{new_name}' and active '{active_name}' "
          f"have different variable sets."
        )
        if only_new:
          notes.append(
            f"#          Variables only in '{new_name}': {', '.join(only_new)}"
          )
        if only_old:
          notes.append(
            f"#          Variables only in '{active_name}': {', '.join(only_old)}"
          )

  return notes


def compute_auto_deactivation(
  items: Dict[str, Any],
  state: Dict[str, Any],
  names_to_activate: List[str],
) -> (List[str], Dict[str, Any], List[str]):
  """
  For each item being activated, if it shares any variable name with an
  already-active item, that active item is considered a mutually-exclusive
  configuration and is auto-deactivated.

  Returns:
    - notes: list of comment lines describing what happens
    - updated_state: new state dict with affected items marked inactive
    - vars_to_unset: list of variable names to unset from deactivated items
  """
  notes: List[str] = []
  vars_to_unset: List[str] = []

  # We'll mutate a copy of state so we can return the updated version
  new_state: Dict[str, Any] = dict(state)

  # Build envs for active items from state
  active_items_env: Dict[str, Dict[str, str]] = {}
  for name, entry in state.items():
    if not isinstance(entry, dict) or not entry.get("active"):
      continue
    env_map = entry.get("vars")
    if not isinstance(env_map, dict):
      item_def = items.get(name)
      if item_def is None:
        continue
      env_map = item_to_env_map(item_def)
    active_items_env[name] = env_map

  for new_name in names_to_activate:
    item_def = items.get(new_name)
    if item_def is None:
      continue
    new_env = item_to_env_map(item_def)
    new_keys = set(new_env.keys())

    for active_name, active_env in active_items_env.items():
      # Don't compare with itself, and don't auto-deactivate something
      # that is also being activated in this same call.
      if active_name == new_name or active_name in names_to_activate:
        continue

      active_keys = set(active_env.keys())
      overlap = new_keys & active_keys
      if not overlap:
        continue

      # Collision: new_name represents a different configuration than active_name
      notes.append(
        f"# NOTE: activating '{new_name}' will deactivate active item "
        f"'{active_name}' due to shared variables: {', '.join(sorted(overlap))}."
      )
      if new_keys != active_keys:
        only_new = sorted(new_keys - active_keys)
        only_old = sorted(active_keys - new_keys)
        notes.append(
          f"# WARNING: items '{new_name}' and '{active_name}' have different "
          "variable sets."
        )
        if only_new:
          notes.append(
            f"#          Variables only in '{new_name}': {', '.join(only_new)}"
          )
        if only_old:
          notes.append(
            f"#          Variables only in '{active_name}': {', '.join(only_old)}"
          )

      # Collect all vars from the deactivated item to unset
      for var in active_env.keys():
        if var not in vars_to_unset:
          vars_to_unset.append(var)

      # Mark the collided item as inactive in state
      prev_entry = dict(new_state.get(active_name, {}))
      prev_entry["active"] = False
      prev_entry["vars"] = active_env
      new_state[active_name] = prev_entry

  return notes, new_state, vars_to_unset


def print_table(items: Dict[str, Any]) -> None:
  """
  Print table like:

  +----------------+----------+--------------------------------+
  | Item           | Active   | Variable                       |
  +================+==========+================================+
  | sample_item    | yes      | VARIABLE_NAME=VALUE            |
  |                | yes      | VARIABLE2_NAME=VALUE2          |
  +----------------+----------+--------------------------------+
  | sample_item2   | no       | VARIABLE3_NAME=VALUE3          |
  +----------------+----------+--------------------------------+
  """
  header_line = "+----------------+----------+--------------------------------+"
  header_sep = "+================+==========+================================+"

  print(header_line)
  print("| Item           | Active   | Variable                       |")
  print(header_sep)

  for name in sorted(items.keys()):
    item_def = items[name]
    env_map = item_to_env_map(item_def)
    active_label = "yes" if env_active(env_map) else "no"

    if not env_map:
      print(f"| {name:<14} | {active_label:<8} | {'':<30} |")
      print(header_line)
      continue

    for idx, (k, v) in enumerate(env_map.items()):
      item_col = name if idx == 0 else ""
      var_str = f"{k}={shorten(v, 40)}"
      print(f"| {item_col:<14} | {active_label:<8} | {var_str:<30} |")

    print(header_line)


def print_config_template() -> None:
  template = {
    "items": {
      "single_item": {
        "values": {
          "EXAMPLE_VAR": "VALUE"
        }
      },
      "multi_item": {
        "values": [
          {"EXAMPLE_VAR1": "VALUE1"},
          {"EXAMPLE_VAR2": "VALUE2"}
        ]
      }
    }
  }
  print(json.dumps(template, indent=2))


def build_parser() -> argparse.ArgumentParser:
  description = (
    "myshellenv.manager — manage named groups of environment variables.\n\n"
    "Config file (JSON) default: ~/.myshellenv.manager\n\n"
    "Example config:\n"
    "{\n"
    "  \"items\": {\n"
    "    \"sample_item\": {\n"
    "      \"values\": [\n"
    "        { \"VARIABLE_NAME\": \"VARIABLE_VALUE\" },\n"
    "        { \"VARIABLE2_NAME\": \"VARIABLE2_VALUE\" }\n"
    "      ]\n"
    "    },\n"
    "    \"sample_item2\": {\n"
    "      \"values\": { \"VARIABLE3_NAME\": \"VARIABLE3_VALUE\" }\n"
    "    }\n"
    "  }\n"
    "}\n\n"
    "To apply changes in your *current shell*, either:\n"
    "  eval \"$(myshellenv.manager-core --activate sample_item)\"\n"
    "or use a wrapper function that evals the output for activate/deactivate."
  )

  epilog = (
    "Operations:\n"
    "  --activate / --deactivate  Emit export/unset commands for given items.\n"
    "  --show                     Dry run: show export commands without changing env.\n"
    "  --check                    Compare current env to config for the given items.\n"
    "  --list                     Show a table of items, vars, and active state.\n"
    "  --gen-config-template      Print an example config JSON and exit.\n\n"
    "Collisions:\n"
    "  If two items share variable names, later items in an --activate list win.\n"
    "  When you activate an item that shares any variable name with an already\n"
    "  active item, the older item is auto-deactivated (its vars are unset).\n"
    "  --show/--check will print notes when items collide or have mismatched\n"
    "  variable sets, so you can see which config will override which."
  )

  parser = argparse.ArgumentParser(
    prog="myshellenv.manager-core",
    description=description,
    epilog=epilog,
    formatter_class=argparse.RawDescriptionHelpFormatter,
  )

  parser.add_argument(
    "-c",
    "--config",
    default=DEFAULT_CONFIG_PATH,
    help=f"Path to config JSON file (default: {DEFAULT_CONFIG_PATH})",
  )
  parser.add_argument(
    "--activate",
    nargs="*",
    metavar="ITEM",
    help="Activate one or more items (names or comma-separated list).",
  )
  parser.add_argument(
    "--deactivate",
    nargs="*",
    metavar="ITEM",
    help="Deactivate one or more items (names or comma-separated list).",
  )
  parser.add_argument(
    "--show",
    nargs="*",
    metavar="ITEM",
    help="Dry run: show export commands for items without changing env.",
  )
  parser.add_argument(
    "--check",
    nargs="*",
    metavar="ITEM",
    help="Compare current environment vs config for the given items.",
  )
  parser.add_argument(
    "--list",
    action="store_true",
    help="List all items, their variables, and whether they are active.",
  )
  parser.add_argument(
    "--gen-config-template",
    action="store_true",
    help="Print an example config JSON and exit.",
  )

  return parser


def main(argv: Optional[List[str]] = None) -> int:
  parser = build_parser()
  args = parser.parse_args(argv)

  has_mutating = bool(args.activate or args.deactivate)
  has_info = bool(args.list or args.show or args.check or args.gen_config_template)

  if not has_mutating and not has_info:
    parser.print_help()
    return 1

  # Avoid mixing env-changing ops with list/template in one call
  if has_mutating and (args.list or args.gen_config_template):
    parser.error(
      "Cannot combine --activate/--deactivate with --list/--gen-config-template "
      "in a single call."
    )

  if args.gen_config_template:
    print_config_template()
    return 0

  try:
    items = load_config(args.config)
  except ConfigError as e:
    print(f"# ERROR: {e}", file=sys.stderr)
    return 1

  state = get_state()

  if args.list:
    print_table(items)
    return 0

  # For show/check, precompute collision notes over all mentioned items once
  if args.show or args.check:
    combined_names = parse_names((args.show or []) + (args.check or []))
    collision_notes = describe_collisions(items, combined_names, state)
    for line in collision_notes:
      print(line)

  if args.show:
    names = parse_names(args.show)
    vars_expected = generate_exports(items, names)
    print("# Dry run: these commands would be executed")
    for k, v in vars_expected.items():
      print(f"export {k}={shlex.quote(v)}")

  if args.check:
    names = parse_names(args.check)
    vars_expected = generate_exports(items, names)
    print("# Diff vs current environment")
    for line in diff_env(vars_expected):
      print(line)

  # Mutating operations: emit shell commands for eval
  commands: List[str] = []
  activation_notes: List[str] = []

  if args.activate:
    names = parse_names(args.activate)

    # Handle auto-deactivation due to collisions with already-active items
    notes, updated_state, vars_to_unset = compute_auto_deactivation(
      items, state, names
    )
    activation_notes.extend(notes)
    state = updated_state

    # Plan exports for new activations (later names override earlier)
    vars_to_set = generate_exports(items, names)

    # First unset vars from auto-deactivated items
    for var in vars_to_unset:
      commands.append(f"unset {var}")

    # Then export new values
    for k, v in vars_to_set.items():
      commands.append(f"export {k}={shlex.quote(v)}")

    # Update state for newly activated items
    for name in names:
      item_def = items.get(name)
      if item_def is None:
        continue
      env_map = item_to_env_map(item_def)
      if not env_map:
        continue
      state[name] = {"active": True, "vars": env_map}

  if args.deactivate:
    names = parse_names(args.deactivate)
    vars_to_unset = generate_exports(items, names)
    for k in vars_to_unset.keys():
      commands.append(f"unset {k}")
    # Update state (keep last known vars if present)
    for name in names:
      item_def = items.get(name)
      if item_def is None and name not in state:
        continue
      prev_entry = dict(state.get(name, {}))
      if "vars" not in prev_entry and item_def is not None:
        prev_entry["vars"] = item_to_env_map(item_def)
      prev_entry["active"] = False
      state[name] = prev_entry

  if commands:
    # Also export updated state
    commands.append(emit_state(state))
    # Print notes first (safe as comments even when eval'd)
    for line in activation_notes:
      print(line)
    for cmd in commands:
      print(cmd)

  return 0


if __name__ == "__main__":
  raise SystemExit(main())
